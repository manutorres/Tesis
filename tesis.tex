\documentclass[oneside]{book}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{epstopdf}

\title{Argumentación en sistemas multi-agente} % do change
\author{Leonardo Molas \and Manuel Torres}

\newtheorem{definicion}{Definición}

\begin{document}

\maketitle
\tableofcontents

\chapter*{Introducción}

%---

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preliminares} % me pareció que iba primero esto y después el juego, pero no sé :P

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Descripción del Juego}

\section{Estado del arte}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Arquitectura} % VER DONDE ES DISEÑO Y DONDE ARQUITECTURA

Este capítulo tiene el objetivo de analizar el diseño y estructura que presenta el 
enfoque de agente propuesto. Primero desde un punto de vista general, para luego 
poner especial énfasis en el módulo dedicado a la toma de decisiones, responsable 
del manejo de las creencias, deseos e intenciones. Serán presentados en detalle los 
componentes básicos del esquema BDI aplicado, así como también las principales 
adaptaciones y agregados realizados en esta implementación particular.

\section{Diseño general}

%\label{sec:diseñoGeneral}

El programa agente presenta una estructura simple en cuanto a su división más general. 
Esto permite su entendimiento a nivel individual, al mismo tiempo que facilita su 
integración en un entorno multi-agente como el enfrentado. La interacción con el entorno 
y el procesamiento inicial de la información recibida finalizan con la generación de una 
serie de creencias que son incorporadas a la base de conocimiento mantenida por el agente. 
Este conjunto de creencias es empleado posteriormente por el módulo encargado de tomar 
decisiones. La forma en que se estructuran los componentes principales es detallada a 
continuación.

\subsection{Estructura básica del agente}

%\label{sec:estructuraBasica}

El programa principal del agente es el encargado de manejar la comunicación con los 
servidores, tanto el del juego como el de percepciones (presentado 
a continuación). También es responsable de parsear y procesar la información contenida 
en la percepción para darle el formato interpretado por la base de conocimientos, y 
enviar la acción que ha sido elegida por el módulo de toma de decisiones.

\begin{figure}
 \centering
 \includegraphics[scale=.3]{agentarchitecture.eps}
 \caption{Diagrama de la arquitectura del agente. Las líneas punteadas representan el 
 flujo de control, y las líneas contínuas representan el flujo de datos.}
 \label{fig:architecture}
\end{figure}

El servidor de percepciones (SP) es un programa independiente, encargado de unificar las 
percepciones de todos los agentes que se encuentran en ejecución. Recibe sus percepciones 
individuales y retorna a cada uno de ellos el conjunto de datos que aún no poseen, de 
manera que todos los agentes del equipo cuenten con la misma información en cuanto al estado 
del escenario.

En cada iteración de la simulación, el agente recibe un mensaje por parte del servidor 
del juego, el cual contiene la información asociada a la percepción del turno en disputa. 
Este mensaje es parseado y traducido en una estructura que permite manipular los datos 
con mayor facilidad. Los datos son divididos en dos conjuntos, uno ``público'', el cual 
es compartido con los demás agentes del equipo, y uno ``privado''. La sección pública de 
datos es compartida a través del mencionado servidor de percepciones.

El agente une entonces su propia percepción con la percepción global recibida del servidor 
de percepciones, y genera un único conjunto de datos. Esta información es incorporada a la 
base de conocimientos, estableciendo nuevas creencias para el agente.

El módulo de toma de decisiones, analizado en la sección \ref{sec:arquitecturaBDI}, es el 
que implementa el modelo BDI respetado por el agente. Este módulo es consultado en cada 
iteración para obtener la próxima acción a ser ejecutada. Una vez que el flujo de control 
retorna al programa principal, la acción seleccionada es enviada al servidor del juego.

\subsection{Base de conocimiento}

%\label{sec:baseConocimiento}

Como fue mencionado, la percepción del agente en cada iteración es convertida a una 
estructura de datos que permite, de manera más sencilla, manipular y compartir la 
información. Cuando el agente cuenta con todos los datos relativos a las percepciones 
del equipo, la base de conocimiento puede ser actualizada convenientemente. Una colección 
de predicados de Prolog consultados desde el programa principal se encarga de verificar 
que la información existente no resulte sobreescrita, y que información redundante no sea 
incorporada. 

La información que constituye conocimiento certero sobre el estado del escenario es 
almacenada mediante términos, que sirven como argumentos del predicado \texttt{k/1} 
(\textit{knowledge}). Cada uno de los datos de interés es representado mediante un 
término diferente. 
En muchos casos, esta clase de términos incluyen un argumento ligado al número de turno 
en el cual el dato fue percibido. De esta forma, es posible realizar ciertos análisis, 
como por ejemplo, considerar obsoleta la información de una determinada antigüedad.

	% En castellano para mantener el idioma y porque las b() 
	% están así.
\begin{verbatim}    
    k(equipoAgente(Agente, Equipo)).
    k(valorNodo(Nodo, Valor)).
    k(arco(Nodo1, Nodo2, Costo)).
    k(posicionAgente(Agente, Turno, Posición)).
    k(equipoNodo(Turno, Nodo, Dueño)).    
\end{verbatim}

Las creencias que provienen de inferencias y cálculos realizados a partir de información 
ya existente también son almacenadas mediante términos, en este caso argumentos del 
predicado \texttt{b/1} (\textit{beliefs}). Este tipo de creencias es empleado directamente 
por el módulo encargado de la toma de decisiones, y se mantienen vigentes sólo durante el 
turno en el cual fueron generadas. Es decir, que, al finalizar cada turno, son descartadas 
para evitar futuros problemas o inconcistencias.

\begin{verbatim}
    b(estoyEnLaFrontera).
    b(posibleExplorar(Nodo)).
    b(haySaboteador(Nodo)).
\end{verbatim}

Existe cierta información que es formulada de manera hipotética. Se trata de datos 
surgidos de suposiciones realizadas sobre posibles estados futuros del escenario, a partir 
de su estado actual. Este tipo de datos resulta fundamental para facilitar los cálculos 
realizados por los algoritmos que se encargan de buscar formas de maximizar el puntaje 
del equipo. Dado que no constituye información real, sino posible a futuro, se almacena 
mediante argumentos de un predicado especial, \texttt{h/1} (\textit{hypothetical}).

\begin{verbatim}
    h(nodoEquipo(Nodo, Dueño)).
    h(posicion(Turno, Agente, Nodo)).    
\end{verbatim}

Las intenciones surgen del proceso argumentativo explicado más adelante, y son 
representadas utilizando términos. Si la intención no posee argumentos, entonces es 
representada mediante un átomo. En otro caso, se emplea un functor que denota el 
nombre de la intención, acompañado por un argumento. Las acciones, por el contrario, 
son representadas a través de listas. El primer elemento de la lista es un atómo denotando 
el tipo de acción. Y el resto de la lista contiene, ocacionalmente, un término que 
indica el argumento de la acción, como por ejemplo el nombre de un nodo o un agente.
Los planes son representados mediante listas de acciones, es decir, listas de listas.

Contrario a lo que ocurre con las creencias, tanto las intenciones como los planes 
constituyen información que debe perdurar en la base de conocimiento tantos turnos 
como sea necesario. Para este tipo de datos se emplean hechos específicos que cuentan 
con un único argumento.

\begin{verbatim}
    intencion(explorar(vertex7)).
    plan([[recharge], [goto, vertex7], [survey]]).
\end{verbatim}

\section{Arquitectura BDI} %CAMBIAR: Toma de decisiones?

\label{sec:arquitecturaBDI}

El módulo de toma de decisiones es consultado por el programa principal, obtiene la 
próxima acción a ser ejecutada, y la retorna para que pueda ser enviada. Esta es una 
secuencia que se reitera en cada uno de los turnos de la simulación, con una característica:
cuando es necesario plantear y planificar una nueva meta, intervienen una serie de 
componentes especiales, que difieren de aquellos involucrados cuando se cuenta con una 
meta ya planificada. Cada uno de estos componentes es descrito en esta sección.

\begin{figure}[h]
 \centering
 \includegraphics[scale=.3]{agentprolog.eps}
 \caption{Diagrama de la arquitectura interna del agente, particularmente todo lo relacionado 
 con la toma de decisiones, hecha en Prolog. Las líneas punteadas representan el 
 flujo de control, y las líneas contínuas representan el flujo de datos.}
 \label{fig:agentProlog}
\end{figure}

\subsection{Seteo de creencias}

\label{sec:seteoCreencias}

El seteo de creencias es llevado a cabo cada vez que el agente se dispone a 
seleccionar una nueva intención. Incluye la generación de aquellos datos que pueden 
permitir al agente realizar una elección lo más acertada posible. Se trata de 
inferencias realizadas en base al estado del escenario, es decir, aquella información 
que, como fue mencionado, es almacenada en \texttt{b/1}. No forma parte de este proceso 
la información proveniente de la percepción, ya que el estado del entorno es actualizado 
en cada turno de manera previa. Como se detalla a continuación, distintos tipos de 
creencias pueden pueden estar relacionadas a distintos factores, como el rol del agente, 
su estado, o los deseos en análisis.

\subsubsection{Creencias generales}

Existe un conjunto de creencias que resultan de utilidad general para todo el proceso 
de decisión. Por esta razón, son las primeras en ser calculadas y almacenadas durante 
el seteo de creencias. Entre los datos incluidos, se encuentra el puntaje que están 
aportando las zonas armadas, la diferencia de puntos que puede producirse si el agente 
abandona su posición, y la seguridad que brindan las distintas ubicaciones posibles en 
cuanto a la presencia de agentes saboteadores enemigos. 

\subsubsection{Deseos}

Como se detallará en el capítulo siguiente, el proceso de toma de decisión conlleva el 
pesaje de todos los posibles deseos del agente, y la posterior selección del más beneficioso. 
Dichos deseos surgen de un conjunto predefinido, y pueden, según sea el caso, estar 
instanciados con diferentes entidades del juego, como agentes o nodos. Para que esta 
selección sea posible, es necesario determinar, de manera previa, qué deseos e instanciaciones 
son realmente factibles, y por lo tanto deben ser tenidos en cuenta, y cuales pueden ser 
descartados anticipadamente.
Para esto se analizan distintas condiciones como, por ejemplo, la distancia a un nodo 
que no ha sido explorado. Si el nodo se encuentra a una distancia que supera una cota 
pre-establecida, entonces el deseo de explorar ese nodo no es contemplado.
Los deseos e instanciaciones considerados factibles son seteados en la base de conocimiento.

\begin{verbatim}
    b(posibleExplorar(vertex4)).
\end{verbatim}

\subsubsection{Creencias específicas} % Seteo de beliefs para cada deseo.

Junto con los deseos a ser evaluados, es necesario incluir en la base de conocimiento 
un conjunto de creencias relacionadas a estos deseos. Entre las más importantes, se 
encuentran las distancias que existen desde la posición actual del agente a los distintos 
nodos de interés, y la diferencia de puntaje que se produce en caso que el agente se desplace 
a dichas ubicaciones. Estos datos resultan fundamentales, ya que afectan directamente la 
valuación que se realiza de cada deseo, y por lo tanto la posterior selección.

En esta etapa, también se produce el seteo de datos requeridos posteriormente, como son 
los caminos a los diferentes nodos analizados. Los algoritmos empleados para la búsqueda 
de caminos almacenan todos los caminos hallados, en forma de secuencia de acciones, de 
manera que la etapa de planificación, ejecutada cuando se ha decidido una intención, 
pueda ser realizada en forma simple e directa.

\subsubsection{Creencias especiales} % Seteo de beliefs en caso de agente deshabilitado.

Cuando el agente se encuentra en una situación de peligro, esto es, no posee el rol de 
saboteador y hay un saboteador enemigo en su posición, o fue atacado en el turno anterior, 
el conjunto de creencias seteadas se reduce. En estos casos, sólo son tenidos en cuenta 
los nodos vecinos, dado que representan las vías de escape más rápidas; son calculadas 
las distancias a estos (en cantidad de turnos), y las diferencias de puntaje que produciría 
el desplazamiento del agente. Esto tiene el objetivo de minimizar la cantidad de deseos 
considerados: sólo son evaluadas la posibilidad de permanecer en la misma ubicación 
(si el beneficio en puntaje es considerable), y las distintas alternativas de defensa 
propia que pueden llevar al agente a superar el peligro.

\subsection{Argumentación}

\label{sec:argumentacion}

Una vez finalizado el seteo de creencias, el agente procede a la selección de la próxima 
intención. Para esto, se toma cada uno de los deseos marcados como factibles en la base 
de conocimiento, y se los evalua junto a una serie de ``condiciones'' particulares. Se 
considera que existen razones para creer realizables sólo aquellos deseos que satisfacen 
sus condiciones. Para estos, se obtiene un valor que representa su peso, en términos del 
beneficio que conllevan para el equipo. El deseo que presenta el mayor peso entre los 
analizados, se convierte en la nueva meta del agente, la cual es almacenada hasta ser 
alcanzada o reemplazada.

Tanto la evaluación como el pesaje de los deseos, son llevados a cabo empleando \textit{argumentación} 
en un módulo especial, implementado con la ayuda de \textit{DeLP}. 
Detalles sobre la implementación y como la argumentación es aplicada en el proceso de 
razonamiento, son estudiados en el capítulo dedicado a la Toma de Decisiones. %referencia, cambiar nombre?

\subsection{Planificación}

%\label{sec:planificacion}

La planificación consiste en obtener la secuencia de acciones que llevan al cumplimiento 
de la intención propuesta. Esta lista está compuesta por las acciones que le permiten al 
agente posicionarse en el nodo deseado, y, en algunos casos, una acción concreta a realizar. 
Como se dijo anteriormente, en la etapa de seteo de creencias, todos los caminos hallados 
por el algoritmo de búsqueda son almacenados. Dicho algoritmo fue implementado de manera 
tal que los caminos no están constituidos por nodos o vértices, sino por una secuencia 
optimal de acciones, que tiene en cuenta no sólo el nodo destino, sino también los recursos 
del agente, y la meta final a realizar (en caso de haber una acción final). De esta forma, 
cualquiera haya sido la intención elegida, el agente cuenta en su base de conocimiento 
con el plan necesario para cumplirla. La planificación se resume entonces a tomar las 
acciones correspondientes, y establecerlas efectivamente como el plan a seguir.

Alternativamente, esta etapa puede introducir ciertas acciones con el objetivo de optimizar 
el uso del turno. En aquellas situaciones en que el agente se dispone a permanecer inactivo, 
la acción nula (\texttt{skip}) puede ser reemplazada por la acción de recargar energía, si es que 
esta resulta más productiva.

\subsection{Ejecución}

\label{sec:ejecucion}

Dado que el plan se encuentra almacenado de manera completa y ordenada, la ejecución se 
realiza en forma directa. Se toma la próxima acción, es decir, la primera acción del plan 
restante, y se la retorna al módulo principal del programa. Este se encarga posteriormente 
de enviarla al entorno, para que se convierta finalmente en la siguiente acción realizada 
por el agente.

\subsection{Condición de corte}

\label{sec:condicionDeCorte}

Existen situaciones en las que el paso de los turnos genera que el cumplimiento de una 
meta se vuelva inalcanzable, innecesario, riesgoso, o menos productivo de lo previsto, por 
lo que resulta más beneficioso abortar el plan existente, y seleccionar una nueva intención. 
Ésta es una etapa de verificación, que tiene como objetivo la detección de este tipo de 
situaciones. Es ejecutada sólo en aquellos turnos en los que el agente se encuentra 
siguiendo el plan de una intención previamente determinada.

Cada deseo o esquema de deseo cuenta con una serie de \textbf{condiciones de corte}, que 
son evaluadas al inicio de cada turno, en caso de existir un plan establecido. Si se verifica 
que alguna de estas condiciones se satisface, entonces la intención es descartada, y el 
agente ingresa en un nuevo proceso de selección. 
Entre las condiciones de corte tenidas en cuenta, se encuentran: 

\begin{itemize}
	\item Que haya pasado una determinada cantidad de turnos desde el inicio del plan.
	\item Que el agente se encuentre deshabilitado.
	\item Que haya sido atacado o se encuentre amenazado por un enemigo.
	\item Que la meta haya sido alcanzada por un compañero de equipo.
\end{itemize}

\subsection{Re-planificación}

%\label{sec:replanificación}

La fase de re-planificación consiste en elaborar nuevamente el plan que permite alcanzar 
la meta propuesta, sin modificar dicha meta. Este paso, como el anterior, se realiza en 
los turnos en los que el agente posee un plan pre-calculado. Dado que en estos turnos no 
es necesaria la obtención de una nueva intención, proceso que implica el mayor insumo de 
tiempo, la inclusión de la re-planificación no afecta el funcionamiento normal del agente, 
en términos de tiempo de ejecución. 

Por el contrario, existe una mejora en el desempeño del equipo, surgida de un mejor 
aprovechamiento de la información percibida. Los agentes actualizan su información sobre 
el estado del mundo en cada turno. Datos como el estado en que se hallan los recursos del 
agente, la incorporación de nodos y arcos hasta el momento desconocidos, o las nuevas 
ubicaciones de los otros agentes, permiten elaborar planes más precisos y ajustados a la 
realidad que los originalmente diseñados. Así, los agentes son capaces de cumplir sus 
metas con mayor facilidad, o abortarlas si es necesario.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Argumentación}

En esta sección se expandirá lo explicado en el capítulo anterior, relacionado a 
la toma de decisiones. Esto es, generación de los deseos, su estructura, la selección de la
intención, en particular su proceso de argumentación (derrotas, tanto por peso como 
propias), todo con ejemplos concretos del programa realizado. Luego, se expondrán los 
diferentes deseos utilizados.


\section{Idea general}

\label{sec:ideaGeneral}

Sin inmiscuirse en los detalles de la implementación, la idea que llevamos a cabo en el 
desarrollo del programa fue un sistema en el que existen un tipo especial de argumentos,
que representan los esquemas de deseos, en cuya signatura contienen un valor numérico.
Este valor es el \textbf{peso} %negrita
del argumento. Cada deseo, al ser un argumento, se calcula examinando la veracidad de sus
precondicones, las cuales pueden ser razones para descartar o garantizar la posibliidad de
su aplicación, y/o hechos que enuncian cuantificaciones acerca del mundo actual (por 
ejemplo, el valor de un nodo o el costo de un arco). Estos valores son utilizados en la
determinación del peso del deseo aplicando un cálculo \textit{ad hoc}, %cursiva
que será explicada luego.

Cada esquema de argumento puede tener otros parámetros en la signatura aparte de su peso,
como por ejemplo el destino en el cual se aplicará la acción deseada. Estos argumentos
pueden instanciarse varias veces con distintos argumentos, dando la posibliidad a que 
entren en conflicto deseos del mismo tipo, pero con diferentes parámetros, y posiblemente
diferentes pesos.

Dados todos los deseos que en efecto serán contrapuestos, con sus respectivos pesos, el 
proceso de selección se realiza enfrentando a todos sus argumentos entre si. Estos 
ataques, en \textit{DeLP}, pueden ser programados de la siguiente manera:

$$ \sim X \leftarrow Y$$ 

Siendo $X$ e $Y$ cualquier argumento de deseo. Este tipo de reglas estrictas, a las que
denominaremos \textit{reglas de cancelación mutua}, se repite 
para todos los deseos existentes, de manera tal de, siendo $\Omega$ el conjunto de las 
metas, haya una regla de cancelación mutua para cada elemento del conjunto
$\Omega \times \Omega$.

Al consultar por la veracidad de cualquiera de los argumentos de los deseos, se 
realizarán una serie de ataques entre ellos. En \textit{DeLP}, la mayoría de ellos
generarán bloqueos, si se 
utilizan los criterios de comparación comunes (estos son \textit{Especificidad} y 
\textit{Derrotadores a asumciones}), ya que los argumentos no tienen necesariamente 
precondicones en común. Por esta razón, se utiliza un nuevo criterio, el cual 
denominaremos \textit{Mayor Peso}. Como su nombre lo indica, compara los pesos de los 
argumentos, si estos existen (y estos sólo existen en los argumentos de deseos). Los 
argumentos con mayor peso derrotan a los de menor.

En el caso de que el peso de dos argumentos sea el mismo, todavía existiría el problema 
de los bloqueos. Esto generaría un problema si justo se tratará de los más pesados, ya 
que ninguno de los dos (o más) deseos estarían garantizados o derrotados, y la consulta
por deseo no devolvería ningún resultado. Por esta razón, se extiende el criterio 
\textit{Mayor Peso}\ para que contemple como caso especial las igualdades de peso. En 
estos casos, se hará una comparación por orden lexicográfico de los argumentos, ya que
no interesa cuál de los dos gane. 

En la figura %mamarracho
se muestra este concepto de derrotas. % explicar

%figura mamarracho

\section{Esquemas de argumento}

\label{sec:esquemasArgumento}

% En el subprograma de toma de decisiones (a partir de ahora subprograma \textit{DeLP}, o simplemente
% \textit{DeLP}), se utilizaron dos tipos de argumentos. En esta sección, se explicará su uso.

El esquema anterior fue el propuesto, pero no exactamente el implementado, ya que
realizamos modificaciones para optimizar los tiempos de ejecución del programa. Sin 
embargo, el concepto de tener varios tipos de argumentos, incluyendo el de deseos, con sus
pesos, se mantuvo. En esta sección se explicarán más en detalle.

\subsection{Argumentos de deseos}

\label{sec:argumentosDeDeseos}

Como fue explicado en la sección \ref{sec:ideaGeneral}, el tipo más importante de 
reglas en el subprograma \textit{DeLP} son los de deseos. Su esquema es el siguiente:

\begin{verbatim}
[Nombre]\(Peso {, [Arg]}*\) (<- | -<) [Precon] {, [Preconds]}*.
\end{verbatim}

Donde:

\begin{itemize}
    \item \textbf{Nombre}: El nombre del deseo.
    \item \textbf{Arg}: Los argumentos (en el sentido de signatura de la regla).
    \item \textbf{Precon}: La primer precondición de la regla. Puede ser \textit{true}, en cuyo
    caso, la regla es un hecho (si es una regla estricta) o asumción (si es una regla 
    rebatible).
    \item \textbf{Precons}: El resto de las precondiciones.

\end{itemize}

El argumento \texttt{Peso} siempre estará en las reglas de deseos en la primera posición.

Al ser consultado por uno de ellos, se generan todas las instancias posibles de estas
reglas, con sus respectivos argumentos. Si por alguna razón, una de las precondiciones no
se puede satisfacer, entonces el argumento queda como \textit{indefinido} %undecided?
y en términos del programa final, es lo mismo a que no sea verdad, o sea, que esté 
derrotado. 

Este caso puede suceder cuando, por ejemplo, se calcula una meta de 
exploración a un nodo X, y se calculan las diferentes creencias necesarias. Si por 
alguna razón, no se puede encontrar un camino a ese nodo, nunca se asertará la creencia
que existe un camino, y cuando llegue el momento de chequear la veracidad del argumento,
el hecho no se encontrará, por lo que el argumento quedará \textit{indefinido}. 

\subsection{Otros argumentos}

El resto de las reglas del programa serán los soportes para las anteriores, 
o sus derrotadores. No 
contendrán peso, aunque serán los medios por los cuales se calcularán éstos, entre
otros usos.

\subsubsection{Contrargumentos para deseos}

Los argumentos de los deseos explicados en \ref{sec:argumentosDeDeseos}\ pueden tener
razones para considerarse inválidas. Este comportamiento es expresado con reglas que 
nieguen dichos deseos, dadas ciertas precondiciones. Éstas tienen la siguiente forma:

\begin{verbatim}
~[NombreDeseo]\(Peso(, [Args])*\) (<- | -<) [Precond] (, [Preconds)*.
\end{verbatim}

Si se trata de una regla rebatible, se debe asegurar que ésta derrote al argumento
de deseo sin generar un bloqueo. Claramente, se podrían escribir otras reglas que
contradigan éstas. Tal comportamiento aprovecharía más la capacidad argumentativa 
de \textit{DeLP}, pero no fue utilizado por no existir la necesidad
en nuestro contexto.

\subsubsection{Crencias}

\label{sec:creencias}

Como fue explicado antes, % link?
un subconjunto de las  \textit{beliefs} será utilizado por el subprograma 
\textit{DeLP}, directamente por 
las reglas de deseos, o indirectamente a través de otras reglas. Estas serán reglas de 
la forma:

\begin{verbatim}
b\([Signatura]\) <- true.
\end{verbatim}

Donde Signatura será un hecho Prolog que contenga la información relevante de la 
creencia. El functor \texttt{b/1} se utilizó para facilitar la búsqueda y 
eliminación de estos hechos. 

Estos hechos no se encuentran en el programa, sino que son asertados en la ejecución
del agente, a partir del procesamiento de su percepción. 
Un ejemplo de éstos sería la siguiente regla:

\begin{verbatim}
b(~esSeguro(vertex34))<-true.
\end{verbatim}

Este hecho determina que en el turno actual, la posición \texttt{vertex34} es peligrosa,
ya que se encuentra un saboteador enemigo parado en él. Varios deseos tienen en cuenta
que la posición a la que irán sea segura, ya que sino entrarían en un posible combate.
Luego, un deseo que necesite tener como parámetro un vértice seguro, lo descartaría.

La existencia o no de estos hechos corresponde con una semántica binaria. Otros tipos de
creencias en el subprograma \textit{DeLP} no se corresponden con ella, a pesar de corresponderse
con el esquema anterior. Se trata de creencias que exponen cuantificaciones a ser 
tenidas en cuenta para el cálculo de los pesos. Un ejemplo de estas creecias es el 
siguiente:

\begin{verbatim}
b(difPuntosSinMi(0))<-true.
\end{verbatim}

En este caso, el hecho expone la cantidad de puntos que se podrían llegar a perder si el
agente se va de su vértice (ya sea porque se mueve o porque deja de estar activado). Esa
cantidad se tiene en cuenta por los argumentos de deseos, para descartar los que generen
mucha pérdida de puntos. ``Mucha pérdida'' se corresponde con un concepto difuso, a
diferencia de los hechos explicados antes. Este valor será el parámetro de una función
de varias variables, que será explicado luego, el cual genera el valor que se usa como
peso del argumento de deseo. Perder cero puntos, como expone el hecho de más arriba, es el
caso ideal de un deseo, por lo que las metas que lo consideren tendrán un puntaje
relativamente alto.

Existen otras creencias de este tipo, que pueden tener otros parámetros además del valor
numerico, como por ejemplo un vértice. El hecho \texttt{difPuntos} es un ejemplo de esto.
Es parecido al anterior, con la diferencia que se instancia con un vértice al cual es
posible llegar en una cantidad pequeña de turnos, y su otro parámetro representa la
cantidad de puntos que ganaría (o perdería, si el valor es negativo) el agente al moverse
a dicho vértice. Por esta razón, puede haber varias de estos hechos instanciados con
distintos vértices la vez.

\subsubsection{Creencias indirectas}

\label{sec:creeciasIndirectas}

Hay algunas creencias que no se generan en tiempo de ejecución del programa Prolog, sino
que se calculan cuando se ejecuta el subprograma \textit{DeLP}. Se trata de típicos argumentos
\textit{DeLP}, que pertenecen a los argumentos de deseos. Se calculan en base a las creencias
expuestas en la sección anterior. Un ejemplo de éstas es la de la Fig. 
\ref{fig:creenciaIndirecta}.

\begin{figure}
\begin{verbatim}
puedoHacerParry -<
    myRole(repairer).

puedoHacerParry -<
    myRole(saboteur).

puedoHacerParry -<
    myRole(sentinel).

~puedoHacerParry <-
    myEnergy(Energy),
    less(Energy,2).
\end{verbatim}

\caption{Ejemplo de una creencia indirecta.}
\label{fig:creenciaIndirecta}

\end{figure}

En este caso, la creencia \texttt{puedoHacerParry}\ se calcula en base al rol del 
agente,
así como también de la energía del agente. Esto es porque no todos los roles tienen la
acción asociada, por lo que se listan las que sí lo pueden. Por otro lado, el agente
no puede hacer \textit{parry}\ si no tiene por lo menos dos puntos de energía, lo cual
es expresado por la última regla.

\subsubsection{Funciones aritméticas y lógicas}

En la última línea de la Fig. \ref{fig:creenciaIndirecta}, se utiliza la función 
\texttt{less/2}, que es una función de comparación. (En ese caso, devuelve lo mismo
que $Energy < 2$.) Ése es un ejemplo de las diferentes funciones aritméticas y 
lógicas que se encuentran en el subprograma \textit{DeLP}.

Estas reglas se encuentran fuera del lenguaje \textit{DeLP}, y fueron implementadas 
aprovechando su capacidad de consultar a Prolog, utilizando \textit{built in's}.
En la figura \ref{fig:funciones}\ se ejemplifica la manera en que se han 
implementado.

\begin{figure}
\begin{verbatim}    
is_a_built_in(less(_X,_Y)).
is_a_built_in(add(_X,_Y,_Z)).

add(X,Y,Z :- Z is X + Y.
less(X,Y) :- X < Y.
\end{verbatim}

\caption{Ejemplo de una función aritmética y una lógica.}
\label{fig:funciones}
\end{figure}

\subsubsection{Cálculo de pesos}

Utilizando la misma idea que la funciones ariméticas de la sección anterior, el
cálculo de los pesos de los argumentos de deseos se logró utilizando \textit{built 
in's}. Existe uno por cada regla de deseo, salvo que esté fijo, en cuyo caso 
este valor simplemente se encontrará en vez de la varialbe \texttt{Peso}. Un 
ejemplo extraído del código se encuentra en la Fig. \ref{fig:calculoDePeso}.

\begin{figure}
\begin{verbatim}
is_a_built_in(aumentoPeso(_, _, _, _, _)).

aumentoPeso(Turnos, DifPuntos, EnergiaRestante, CoefFase, Peso) :-
    Value is (DifPuntos * 10 + (10 - Dist) ** 2 + EnergyLeft) * 
    		CoefFase.
\end{verbatim}

\caption{Ejemplo del cálculo del peso de un argumento de deseo.}
\label{fig:calculoDePeso}
\end{figure}

En este ejemplo, se calcula el peso del deseo \emph{aumento}. Para esto, se utilizan
varios parámetros, entre las cuales se encuentran la cantidad de turnos que 
conllevará realizarlo, y la diferencia de puntos que genera.

Todas estas funciones cumplen con el protocolo de mantener el nombre del deseo,
seguido de ``Peso'' como nombre. A su vez, mantiene todos los parámetros 
necesarios como argumentos, seguido de la variable \texttt{Peso}, en la cual se 
retornará dicho valor.

\subsubsection{Coeficientes y otros valores auxiliares}

En la fórmula de la figura \ref{fig:calculoDePeso}\ se utiliza el valor 
\texttt{CoefFase}. Este valor no pertenece a lo obtenido en las percepciones, ni
directa ni indirectamente, sino que se trata de un valor preestablecido (o
\textit{harcodeado}). Pertenece a esta categoría aparte de creencias predefinidas,
cuyos valores modifican los pesos ya sea de manera aditiva/substractiva, o 
porcentualmente (como es el caso de \texttt{CoefFase}).

En particular, este valor se refiere a un coeficiente que se le aplica a varios
pesos de deseos, que representa la utilidad de cada deseo en la fase actual. El 
concepto de \textit{``fase''}\ se trata de un modificador más del comportamiento
del agente, que cambia de acuerdo a diferentes parámetros, como por ejemplo una
determinada cantidad de turnos, proporción de muertes, porcentaje de mapa explorado,
etc. Fue implementada la interfaz para utilizarla, pero no se expandió a más de una
fase inicial de exploración, por cuestiones de falta de tiempo.

Otros valores caen dentro de esta categoría, como \texttt{agentRolePoints/3}.
Se utiliza para agregar (o sustraer) una determinada cantidad de turnos, dado el
deseo y el rol del agente al cual está apuntado el deseo. Esto sirve para modificar el 
comportamiento de una manera sencilla y modular, para los deseos y roles que los 
necesiten.

Se necesitarían $|D| \times |R|$ reglas para determinar estos valores, siendo $D$
y $R$ los conjuntos de deseos y roles respectivamente. Ésto se simplificó utilizando
un valor por defecto neutral ($0$). Este comportamiento es mostrado
en la Fig. \ref{fig:agentRolePoints}. En éste se muestra la implementación del caso
general, y el caso especial del deseo \emph{reparar}\ para el rol \emph{repairer}.
Agregarle 70 puntos al peso implica darle mayor importancia reparar a otro reparador,
antes que hacerlo con cualquier otro agente.

\begin{figure}
\begin{verbatim}
% en arg.delp
agentRolePoints(_, _, 0) -< true.
	
~agentRolePoints(D, R, 0) <- 
	agentRolePoints(D, R, V),
	notEqual(V, 0).
    
% en repairer.delp
agentRolePoints(reparar, repairer, 70) <- true.
\end{verbatim}
\caption{Implementación de \texttt{agentRolePoints/3}, para el caso general, y para el 
deseo de \emph{reparar}\ para el \emph{repairer}}
\label{fig:agentRolePoints}
\end{figure}


\section{Interfaz con Prolog}

\label{sec:interfazConProlog}

Teniendo ya todos las reglas de deseos, con sus cálculos de pesos, así como el resto 
de las explicadas en la sección \ref{sec:esquemasArgumento}, el agente debe, por un 
lado, asertar (en el sentido de Prolog) todas las creencias, y luego consultar por 
la intención que se llevará a cabo. Todo esto se hace desde el programa Prolog, en
la parte de Argumentación.

Como fue explicado en el capítulo anterior, %REFFFFFFFFF
las creencias se setean de una manera diferenciada, tratando de realizar la menor
cantidad de cálculos posibles, de manera tal de reducir el tiempo de ejecución. Las
utilizadas por el subprograma \textit{DeLP} serán justamente los hechos \textit{DeLP}, 
y la interfaz utilizará los deseos instanciados con sus respectivos parámetros.

El esquema explicado en la sección \ref {sec:ideaGeneral}\ contiene un esquema de 
derrotas diferente al implementado. Nuestro enfoque fue más simple, y consistió en 
hacer una llamada por cada deseo, manteniendo el deseo de mayor peso, y comparándolo 
con el último consultado. De esta manera, simplemente se hace un chequeo por cada 
consulta, lo cual reduce la cantidad de comparaciones a ser computadas, ya que la idea 
original implementada en \textit{DeLP} hubiera realizado una cantidad logarítmica de 
comparaciones con respecto a la cantidad de deseos, al generar el árbol de derrotas. De 
esta manera, se logró el mismo esquema implícitamente.

En la figura \ref{fig:interfazProlog}\ se puede observar el código Prolog que 
ejecuta las diferentes consultas. Se hace uso de varios \texttt{foreach/3}\ para 
recolectar todos los hechos que guardan los deseos instanciados, nombrados como:

\begin{verbatim}
posible[NombreDeseo]
\end{verbatim}

\begin{figure}
\begin{verbatim}
meta(X) :- 
    retractall(mejorMeta(_, _)),
    assert(mejorMeta(_, -1000)), !, % meta con "menos infinito"
    
    foreach(
        b(posibleExplorar( N1)), 
        doNotFail(calcMeta(explorar( N1)))
    ), !,
    foreach(
        b(posibleAumento(N2)), 
        doNotFail(calcMeta(aumento(N2)))
    ), !, 
    foreach(
        b(posibleAuxilio(N3)), 
        doNotFail(calcMeta(auxilio(  N3)))
    ), !,
    
	doNotFail(calcMeta(reagruparse)),
    doNotFail(calcMeta(quedarse(Position))), !,
    rolMetas, % predicado definido en cada rol
    
    mejorMeta(X, _).
    
\end{verbatim}
\caption{Implementación del predicado \texttt{meta/1}, el cual consulta por cada 
deseo.}
\label{fig:interfazProlog}
\end{figure}

Finalmente, se devuelve el deseo con más peso, para ser considerada como intención,
sin su peso, pero con todo el resto de sus parámetros. %el gotti me va a pegar


\section{Selección de la Intención}

El esquema modelo de un argumento de deseo es el que se encuentra en la Fig. 
\ref{fig:modeloArgumento}. Algunos contienen variaciones con respecto a éste, pero
la mayoría comparte esta estructura.

\begin{figure}
\begin{verbatim}
% "Vertice" es el vertice al cual se quiere expandir
aumento(Peso, Vertice) -< 
    % 1 - Primero se colocan las creencias binarias (sí o no).
    
    esSeguro(Vertice), 
    
    % 2 - Luego, las creencias difusas.
    % Éstas tienen pueden estar asertadas o no. Si no lo están, significa
    % que no se encontró su valor. Por ejemplo, en el caso de la distancia,
    % si no se encuentra es porque no se encontró camino.
    
    b(distancia(Vertice, [], Dist, EnergyLeft)),
    b(difPuntosZona(Vertice, DifPuntos)),
    
    % 3 - Pueden existir razones fuertes para descartar el deseo.
    % En este caso, se trata de que no se considerará expandirse a un 
    % vértice que disminuya la cantidad de puntos.
    
    greater(DifPuntos, 0),
    
    % X - Puede haber modificadores, como coeficientes.
    
    phaseCoef(aumento, Coef),
    
    % 4 - Finalmente, se calcula el peso, con todos los valores.
    
    aumentoValue(Dist, DifPuntos, EnergyLeft, Coef, Peso).
\end{verbatim}
\caption{Modelo de deseo. Los números en los comentarios representan los posibles 
puntos de ataque.}
\label{fig:modeloArgumento}
\end{figure}

En el proceso de selección de intención, se atacan, como fue explicado anteriormente,
explícita o implícitamente los deseos, ya sea por razones propias 
para rechazarlo, o por peso. Los puntos de ataque se encuentran expuestos en la Fig. 
\ref{fig:modeloArgumento}.

\subsection{Derrotas propias}

Un deseo puede ser desechado por razones propias. En esta sección se expondrán estos
posibles puntos de ataques.

En la jerga de DeLP, una derrota propia es aquella en la cual uno de los dos 
argumentos que entra en conflicto sale victorioso (se mantiene \emph{undefeated}),
mientras que el otro es derrotado. En nuestro contexto, consideramos a las 
``derrotas propias de argumentos de deseos'' como ``derrotas por razones propias''. 
O sea, se trata de razones por las cuales un argumento de deseo no es seleccionado
para ser la siguiente intención a llevar a cabo.

\subsubsection{Falta de hechos}

\label{sec:faltaDeHechos}

Para los dos primeros puntos del modelo se necesitan hechos previamente asertados 
por el programa Prolog. La falta de estos corresponde con que no pudieron ser 
encontrados, por alguna razón, y por lo tanto impedirán que cualquier deseo 
relacionado no pueda considerarse como válido.

La consulta en DeLP de un literal en cuyas reglas no se puede satisfacer por lo
menos una de las precondiciones, devuelve 
\texttt{undecided}, ya que no pertenece al conjunto de literales sobre los cuales
el programa DeLP puede determinar su veracidad o falsedad. Nuestra idea fue 
considerar estos resultados de la misma manera que con los que devuelvo \texttt{no}
como respuesta, por lo que, dentro de nuestro sistema, estos ``argumentos'' son
considerados como derrotados por razones propias.

\subsubsection{Precondiciones negadas}

Las precondiciones pueden ser encontradas, pero negadas. Esto significa que existen
razones para creer exactamente lo contrario de lo que el argumento de deseo 
necesita para ser considerada válida. Generalmente, este tipo de derrotas se 
encuentran en el punto 1 de la Fig. \ref{fig:modeloArgumento}, pero pueden 
encontrarse también en el punto 3. En estos casos, la consulta sí devuelve 
\texttt{no} como respuesta.

En el caso de \texttt{esSeguro/1}, se define que cualquier vértice es por defecto
seguro, salvo que se especifique lo contrario (esto es, se aserte un hecho
\texttt{~esSeguro}). En Prolog se especificará que un vértice no es seguro cuando
un saboteador enemigo habiilitado se encuentre parado sobre éste.

\subsubsection{Valores inválidos}

El punto de ataque 3 se conforma de reglas que establecen parámetros estrictos
sobre los valores que se obtienen en el punto 2. Se trata de aserciones, no en el 
sentido \textit{prologiano}, sino como una condición que deben cumplir los valores. 

En el caso del ejemplo de la Fig.
\ref{fig:modeloArgumento}, se desechan los vértices hacia los cuales moverse 
implica no ganar puntos, o sea, el valor obtenido en \texttt{difPuntos}\ es no
positiva. Esto es porque no tiene sentido el concepto de \emph{aumentar} una zona
si se pierden puntos.

Se trató de evitar usar este sistema, no porque éste sea ineficiente, sino 
porque este tipo de chequeos pueden realizarse en Prolog, y, siendo el caso que
no lo pasaran, simplemente no aserta la creencia en cuestión. Además, se puede
ahorrar el cálculo de las siguientes creencias relacionadas con el deseo. De esta
manera, la derrota caería en el caso explicado en la sección 
\ref{sec:faltaDeHechos}.

\subsection{Derrotas por Peso}

Siendo el caso que no se genere ninguno de los tipos anteriores de derrotas, el
deseo es un deseo válido, o sea, para tener en cuenta. Entonces, su consulta 
devolverá \texttt{yes}, con su peso asociado, y entrará en conflicto con el resto
de los deseos válidos.

Como fue explicado en la sección \ref{sec:interfazConProlog}, la interfaz con 
Prolog mantiene el deseo con mayor peso hasta que consigue otro que lo destrone.
De esta manera, implícitamente se genera una derrota fuera de DeLP entre 
argumentos de deseo, en la cual sólo gana uno. (En el caso que se encuentre un 
deseo con el mismo peso que el actual, éste se mantiene.) Se puede considerar
que el punto de este tipo de ataque es el punto 4 de la Fig. 
\ref{fig:modeloArgumento}, ya que es donde se calcula el peso del argumento.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Creencias}

En las sección \ref{sec:creencias} se da el marco
sobre el cual se utilizan las creencias, que son seteadas como se explicó en la sección
\ref{sec:seteoCreencias}.
A medida que se fue desarrollando el sistema, se fueron requiriendo varias de éstas,
mientras se iban diagramando e implementando los argumentos de deseos. Muchas tienen
razones particulares que no necesariamente son intuitivas, por lo que en este capítulo
se enumerarán y explicarán estas creencias, que luego serán utilizadas en el siguiente
capítulo.

Se hará incapié en las que sean utilizadas más de una vez, dejando las más específicas
para ser explicadas en el capítulo siguiente cuando sea necesario.


\section{Creencias simples}

Las \textbf{creencias simples}\ será todo aquello que sólo necesite una consulta, y no
una computación extensa. Entre éstas se encuentran, por ejemplo, todo aquello que venga
en la percepción. Para éstas, muchas veces se utilizó una consulta directa a Prolog,
utilizando el predicado \verb@is_a_built_in@, de manera tal de no tener que 
re-asertarlos en forma de hechos DeLP. En la Fig. \ref{fig:creenciasSimples}\ se ven
algunos de los hechos utilizados.

\begin{figure}
\begin{verbatim}
is_a_built_in(role(_, _)).
is_a_built_in(position(_, _)).
is_a_built_in(myMaxHealth(_)).
is_a_built_in(myHealth(_)).
is_a_built_in(myRole(_)).
is_a_built_in(myEnergy(_)).
is_a_built_in(myPosition(_)).
is_a_built_in(myStatus(_)).
is_a_built_in(myTeam(_)).
is_a_built_in(myName(_)).
is_a_built_in(currentStep(_)).
\end{verbatim}
\caption{Algunas de las creencias simples utilizadas.}
\label{fig:creenciasSimples}
\end{figure}


\section{Creencias complejas}

Otras creencias deben ser computadas previamente antes de ser consultadas, ya que no
son triviales. Muchas se generan de una manera compulsiva, o sea, se calculan siempre,
que llamaremos \textbf{creencias regulares},
y otras se calculan sólo cuando tienen un deseo asociado, o \textbf{creencias 
transitorias}.


\subsection{Creencias regulares}

Estas creencias son necesarias siempre, ya sea que lo sean para el seteo de 
\textit{beliefs}, y/o para la toma de decisiones, ya sea que se use en la mayoría
de los deseos, o en deseos que se calculen siempre. Por esta razón, se calculan
de manera compulsiva todos los turnos.


\subsubsection{Vértices alcanzables}

En la búsqueda de caminos para realizar las diferentes intenciones, no tiene sentido
extender demasiado la búsqueda a caminos de una longitud considerable, ya que el 
estado del mapa es muy cambiante, y muy probablemente dejarían de tener sentido. Por
esta razón, todos los turnos se calcula la distancia de cada vértice 
\textbf{alcanzable}\ y se almacena como un hecho Prolog, para ser usado en el 
cálculo de los deseos.

\begin{definicion}
Un vértice será \textbf{alcanzable}\ si está a una distancia menor a $D$, donde $D$
será un parámetro del sistema, previamente asignado.
\end{definicion}

Este cálculo se realiza en un solo \textit{breadth first search}, asertando los hechos
\texttt{verticeADistancia/2}. En versiones previas del sistema, en el seteo de deseos
se calculaban estas distancias, realizando una búsqueda por cada esquema de deseo, 
pero se optó por este método para realizar una sola búsqueda.


\subsubsection{Vértices visibles y explorados}

Para determinar el estado de conocimiento del mapa, tanto de las conexiones
entre vértices, como del conomiento actual, en todos los turnos se calculan
lo que hemos denominado como \texttt{vértices explorados} y \texttt{vértices 
visibles}. 

\begin{definicion}
Un vértice será considerado \textbf{explorado}\ por el equipo $X$ si en algún 
turno menor o igual al actual haya estado a una distancia menor a $r$ del agente
$A$, siendo el agente $A$ miembro de $X$, y $r$ el rango de visión de $A$.
\end{definicion}

Bajo esta definición, se puede asegurar que si un vértice está explorado, se 
conocen todos sus vecinos. En el caso trivial, cualquier vértice que haya sido
pisado alguna vez por algún agente estará explorado, ya que todos tienen por lo 
menos un rango de visión igual a 1. Luego, si es igual a 2, se considerarán
explorados tanto su posición, como los vecinos de éste.

A la hora de calcular el puntaje del mapa utilizando el algoritmo de coloreo,
es importante tener en cuenta que no se conoce todo el mapa, lo que es conocido 
como \textit{fog of war}. Para esto, se debe determinar el estado de visibilidad
de los vértices conocidos. 

\begin{definicion}
Un vértice será \textbf{visible}\ en el turno actual para el equipo $X$ si se 
encuentra a distancia 
menor a $r$ del agente $A$, siendo $A$ un miembro de $X$, y $r$ el rango de visión 
de $A$. También será considerado visible si está explorado, y para cada vecino suyo 
existe por lo menos un agente que lo tiene dentro de su rango de visión.
\end{definicion}

De esta manera, nos aseguramos de que todo aquel vértice al cual sea considerado 
como visible, para todo vecino suyo existe por lo menos un agente del equipo 
que lo ve. Podemos observar también que la definición de visible es más fuerte que
de explorado.


\subsubsection{Puntajes}

Utilizando nuestra implementación del algoritmo de coloreo, se calculan algunas
creencias necesarias para realizar otros cálculos. La primer consulta se hace con
el mapa tal cual se recibe en la percepción, de manera tal de obtener el puntaje
actual, el cual será utilizado como referencia para calcular las diferencias de
puntajes dados por movimientos de los agentes. Este valor se utiliza solamente
en Prolog, esto es, no en DeLP, y se almacena en el hecho \texttt{b(puntajeActual)}.

Se podría utilizar el puntaje que se obtiene en la percepción, ahorrándose
su computación. Se decidió no realizarlo de esta manera, ya que el algoritmo de 
coloreo puede dar un resultado erróneo, al ser una aproximación por realizarse
sobre un mapa incompleto. De esta manera, como sólo interesa la diferencia 
relativa, ésta será calculada sobre dos magnitudes obtenidas con el mismo 
método.

La creencia que sí es almacenada como hecho DeLP es la diferencia de puntos entre
el mapa sin la presencia del agente, y el mapa actual, al cual denominamos
\texttt{difPuntosSinMi}.


\subsubsection{Frontera}

Conocer la frontera de la zona del equipo es un dato importante para los agentes,
ya que un movimiento incorrecto de un agente que se encuentre en ésta puede 
generar una baja considerable del puntaje de zona. Por esta razón, definimos a
la frontera de la siguiente manera:

\begin{definicion}
Un vértice $V$ se encuentra en la frontera de la zona del equipo $X$, si $V$ 
pertenece a la zona de $X$, existe un vecino $V'$ de $V$ que pertenece a la zona 
de $X$, y existe un vecino $V''$ distinto de $V'$ que no pertenzca al equipo $X$. 
O sea, puede ser que no pertenezca a ningún equipo, o al equipo enemigo.
\end{definicion}

Esto queda almacenado en el hecho Prolog \texttt{b(frontera(Vertice))}, para ser
utilizado luego en el seteo de deseos.


\subsubsection{Defensivas}

Dado que en cualquier momento un agente puede ser atacado por algún saboteador 
enemigo, se deben generar creencias que establezcan si el agente ha sido herido.
Para esto, se calcula si el agente perdió vida en el último turno. Puede suceder
que el agente se haya movido de vértice en la última acción, y que esta haya sido
satisfactoria, y en tal caso se considerará que el agente no está en un vértice
peligroso. Si esas condiciones no se cumplen, se asertará la creencia 
\texttt{mePegaron}.

Otro dato importante es la posición de los saboteadores habilitados enemigos.
Éstos son asertados en la creencia \texttt{b(haySaboteador(Posicion))}, donde 
\texttt{Posicion}\ es la posición de dicho agente.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Deseos Posibles}

Hasta aquí, se han presentado el marco teórico sobre el cual se trabajó, el contexto
de la competencia, y la manera en que hemos abordado el problema de la selección de
intenciones. A pesar de haber utilizado algunos ejemplos propios del código de los 
agentes, no se han explicado en detalle los diferentes deseos utilizados, y los 
detalles de implementación de éstos, como las decisiones de diseño tomadas.

En este capítulo se abordarán estos temas, de manera tal de mostrar el extenso 
trabajo realizado para la competencia.

\section{Deseos Comunes}

A pesar de tener un comportamiento distinto determinado por los roles, los agentes
tienen un grueso cuerpo de código común, tanto en la arquitectura general, como 
en la parte argumentativa. De esta manera, la mayoría de los deseos implementados son
compartidos por todos los agentes, y representan los comportamientos comunes de éstos.

\subsection{Explorar}

El deseo de explorar se refiere a conocer más el mapa. Es disparado para 
conocer mejor las conexiones entre los vértices (arcos). Se instancia con los vértices
que se encuentran en la frontera del mapa conocido. O sea, en los nodos que se sabe
que existen, pero no necesariamente se conocen todos sus arcos. El plan que genera 
consiste en una serie de \textit{goto's}\ hasta llegar al vértice en cuestión, y 
culmina con un \textit{survey}.

Estos nodos no explorados se calculan en el programa Prolog, teniendo en cuenta los 
nodos agregados al mapa conocido por la última percepción. Se tendrán en cuenta sólo
aquellos que se encuentren a una distancia $r - 1$ del nodo del agente, siendo $r$
el rango de visión de éste. Un vértice explorado se mantendrá así por todo el 
transcurso del partido.

Utiliza los datos de cantidad de turnos que costará el plan, y la diferencia de puntos.
El deseo está dividido en dos con respecto a esta última creencia. En el caso que la
cantidad de turnos sea poca (menor a 3), se considerará la creencia 
\texttt{difPuntosZona}. En cambio, si es mayor o igual a 3, se utilizará la creencia
\texttt{difPuntosSinMi}. Esto es porque tiene sentido considerar la suma de puntos
de zona sólo si sucede en pocos turnos, ya que en más el mapa cambiará 
considerablemente. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Consideraciones generales}
% qué iba aca?


\end{document}
