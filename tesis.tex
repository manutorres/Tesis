\documentclass[oneside]{book}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}

\title{Argumentación en sistemas multi-agente} % do change
\author{Leonardo Molas \and Manuel Torres}

\begin{document}

\maketitle
\tableofcontents

\chapter*{Introducción}

---

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preliminares (Estado del arte)} % me pareció que iba primero esto y después el juego, pero no sé :P

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preliminares (Del juego)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Arquitectura}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Toma de decisiones}

En esta sección se expandirá lo explicado en el capítulo anterior, relacionado a 
la toma de decisiones. Esto es, generación de los deseos, su estructura, la selección de la
intención, en particular su proceso de argumentación (derrotas, tanto por peso como 
propias), todo con ejemplos concretos del programa realizado. Luego, se expondrán los 
diferentes deseos utilizados.


\section{Idea general}

\label{sec:ideaGeneral}

Sin inmiscuirse en los detalles de la implementación, la idea que llevamos a cabo en el 
desarrollo del programa fue un sistema en el que existen un tipo especial de argumentos,
que representan los esquemas de deseos, en cuya signatura contienen un valor numérico.
Este valor es el \textbf{peso} %negrita
del argumento. Cada deseo, al ser un argumento, se calcula examinando la veracidad de sus
precondicones, las cuales pueden ser razones para descartar o garantizar la posibliidad de
su aplicación, y/o hechos que enuncian cuantificaciones acerca del mundo actual (por 
ejemplo, el valor de un nodo o el costo de un arco). Estos valores son utilizados en el
determinación del peso del deseo aplicando un cálculo \textit{ad hoc}, %cursiva
que será explicada luego.

Cada esquema de argumento puede tener otros parámetros en la signatura aparte de su peso,
como por ejemplo el destino en el cual se aplicará la acción deseada. Estos argumentos
pueden instanciarse varias veces con distintos argumentos, dando la posibliidad a que 
entren en conflicto deseos del mismo tipo, pero con diferentes parámetros, y posiblemente
diferentes pesos.

Dados todos los deseos que en efecto serán contrapuestos, con sus respectivos pesos, el 
proceso de selección se realiza enfrentando a todos sus argumentos entre si. Estos 
ataques, en \textit{DeLP}, pueden ser programados de la siguiente manera:

$$ \sim X \leftarrow Y$$ 

Siendo $X$ e $Y$ cualquier argumento de deseo. Este tipo de reglas estrictas, a las que
denominaremos \textit{reglas de cancelación mutua}, se repite 
para todos los deseos existentes, de manera tal de, siendo $\Omega$ el conjunto de las 
metas, haya una regla de cancelación mutua para cada elemento del conjunto
$\Omega \times \Omega$.

Al consultar por la veracidad de cualquiera de los argumentos de los deseos, se 
realizarán una serie de ataques entre ellos. En \textit{DeLP}, la mayoría de ellos
generarán bloqueos, si se 
utilizan los criterios de comparación comunes (estos son \textit{Especificidad} y 
\textit{Derrotadores a asumciones}), ya que los argumentos no tienen necesariamente 
precondicones en común. Por esta razón, se utiliza un nuevo criterio, el cual 
denominaremos \textit{Mayor Peso}. Como su nombre lo indica, compara los pesos de los 
argumentos, si estos existen (y estos sólo existen en los argumentos de deseos). Los 
argumentos con mayor peso derrotan a los de menor.

En el caso de que el peso de dos argumentos sea el mismo, todavía existiría el problema 
de los bloqueos. Esto generaría un problema si justo se tratará de los más pesados, ya 
que ninguno de los dos (o más) deseos estarían garantizados o derrotados, y la consulta
por deseo no devolvería ningún resultado. Por esta razón, se extiende el criterio 
\textit{Mayor Peso}\ para que contemple como caso especial las igualdades de peso. En 
estos casos, se hará una comparación por orden lexicográfico de los argumentos, ya que
no interesa cuál de los dos gane. 

En la figura %mamarracho
se muestra este concepto de derrotas. % explicar

%figura mamarracho

\section{Esquemas de argumento}

\label{sec:esquemasArgumento}

% En el subprograma de toma de decisiones (a partir de ahora subprograma \textit{DeLP}, o simplemente
% \textit{DeLP}), se utilizaron dos tipos de argumentos. En esta sección, se explicará su uso.

El esquema anterior fue el propuesto, pero no exactamente el implementado, ya que
realizamos modificaciones para optimizar los tiempos de ejecución del programa. Sin 
embargo, el concepto de tener varios tipos de argumentos, incluyendo el de deseos, con sus
pesos, se mantuvo. En esta sección se explicarán más en detalle.

\subsection{Argumentos de deseos}

\label{sec:argumentosDeDeseos}

Como fue explicado en la sección \ref{sec:ideaGeneral}, el tipo más importante de 
reglas en el subprograma \textit{DeLP} son los de deseos. Su esquema es el siguiente:

\begin{verbatim}
[Nombre]\(Peso {, [Arg]}*\) (<- | -<) [Precon] {, [Preconds]}*.
\end{verbatim}

Donde:

\begin{itemize}
    \item [Nombre] El nombre del deseo.
    \item [Arg] Los argumentos (en el sentido de signatura de la regla).
    \item [Precon] La primer precondición de la regla. Puede ser \textit{true}, en cuyo
    caso, la regla es un hecho (si es una regla estricta) o asumción (si es una regla 
    rebatible).
    \item [Precons] El resto de las precondiciones.

\end{itemize}

El argumento \texttt{Peso} siempre estará en las reglas de deseos en la primera posición.

Al ser consultado por uno de ellos, se generan todas las instancias posibles de estas
reglas, con sus respectivos argumentos. Si por alguna razón, una de las precondiciones no
se puede satisfacer, entonces el argumento queda como \textit{indefinido} %undecided?
y en términos del programa final, es lo mismo a que no sea verdad, o sea, que esté 
derrotado. 

Este caso puede suceder cuando, por ejemplo, se calcula una meta de 
exploración a un nodo X, y se calculan las diferentes creencias necesarias. Si por 
alguna razón, no se puede encontrar un camino a ese nodo, nunca se asertará la creencia
que existe un camino, y cuando llegue el momento de chequear la veracidad del argumento,
el hecho no se encontrará, por lo que el argumento quedará \textit{indefinido}. 

\subsection{Otros argumentos}

El resto de las reglas del programa serán los soportes para las anteriores, 
o sus derrotadores. No 
contendrán peso, aunque serán los medios por los cuales se calcularán éstos, entre
otros usos.

\subsubsection{Contrargumentos para deseos}

Los argumentos de los deseos explicados en \ref{sec:argumentosDeDeseos}\ pueden tener
razones para considerarse inválidas. Este comportamiento es expresado con reglas que 
nieguen dichos deseos, dadas ciertas precondiciones. Éstas tienen la siguiente forma:

\begin{verbatim}
~[NombreDeseo]\(Peso(, [Args])*\) (<- | -<) [Precond] (, [Preconds)*.
\end{verbatim}

Si se trata de una regla rebatible, se debe asegurar que ésta derrote al argumento
de deseo sin generar un bloqueo. Claramente, se podrían escribir otras reglas que
contradigan éstas. Tal comportamiento aprovecharía más la capacidad argumentativa 
de \textit{DeLP}, pero no fue utilizado por no existir la necesidad
en nuestro contexto.

\subsubsection{Crrencias}

Como fue explicado antes, % link?
un subconjunto de las  \textit{beliefs} será utilizado por el subprograma 
\textit{DeLP}, directamente por 
las reglas de deseos, o indirectamente a través de otras reglas. Estas serán reglas de 
la forma:

\begin{verbatim}
b\([Signatura]\) <- true.
\end{verbatim}

Donde Signatura será un hecho Prolog que contenga la información relevante de la 
creencia. El functor \texttt{b/1} se utilizó para facilitar la búsqueda y 
eliminación de estos hechos. 

Estos hechos no se encuentran en el programa, sino que son asertados en la ejecución
del agente, a partir del procesamiento de su percepción. 
Un ejemplo de éstos sería la siguiente regla:

\begin{verbatim}
b(~esSeguro(vertex34))<-true.
\end{verbatim}

Este hecho determina que en el turno actual, la posición \texttt{vertex34} es peligrosa,
ya que se encuentra un saboteador enemigo parado en él. Varios deseos tienen en cuenta
que la posición a la que irán sea segura, ya que sino entrarían en un posible combate.
Luego, un deseo que necesite tener como parámetro un vértice seguro, lo descartaría.

La existencia o no de estos hechos corresponde con una semántica binaria. Otros tipos de
creencias en el subprograma \textit{DeLP} no se corresponden con ella, a pesar de corresponderse
con el esquema anterior. Se trata de creencias que exponen cuantificaciones a ser 
tenidas en cuenta para el cálculo de los pesos. Un ejemplo de estas creecias es el 
siguiente:

\begin{verbatim}
b(difPuntosSinMi(0))<-true.
\end{verbatim}

En este caso, el hecho expone la cantidad de puntos que se podrían llegar a perder si el
agente se va de su vértice (ya sea porque se mueve o porque deja de estar activado). Esa
cantidad se tiene en cuenta por los argumentos de deseos, para descartar los que generen
mucha pérdida de puntos. ``Mucha pérdida'' se corresponde con un concepto difuso, a
diferencia de los hechos explicados antes. Este valor será el parámetro de una función
de varias variables, que será explicado luego, el cual genera el valor que se usa como
peso del argumento de deseo. Perder cero puntos, como expone el hecho de más arriba, es el
caso ideal de un deseo, por lo que las metas que lo consideren tendrán un puntaje
relativamente alto.

Existen otras creencias de este tipo, que pueden tener otros parámetros además del valor
numerico, como por ejemplo un vértice. El hecho \texttt{difPuntos} es un ejemplo de esto.
Es parecido al anterior, con la diferencia que se instancia con un vértice al cual es
posible llegar en una cantidad pequeña de turnos, y su otro parámetro representa la
cantidad de puntos que ganaría (o perdería, si el valor es negativo) el agente al moverse
a dicho vértice. Por esta razón, puede haber varias de estos hechos instanciados con
distintos vértices la vez.

\subsubsection{Creencias indirectas}

Hay algunas creencias que no se generan en tiempo de ejecución del programa Prolog, sino
que se calculan cuando se ejecuta el subprograma \textit{DeLP}. Se trata de típicos argumentos
\textit{DeLP}, que pertenecen a los argumentos de deseos. Se calculan en base a las creencias
expuestas en la sección anterior. Un ejemplo de éstas es la de la Fig. 
\ref{fig:creenciaIndirecta}.

\begin{figure}
\begin{verbatim}
puedoHacerParry -<
    myRole(repairer).

puedoHacerParry -<
    myRole(saboteur).

puedoHacerParry -<
    myRole(sentinel).

~puedoHacerParry <-
    myEnergy(Energy),
    less(Energy,2).
\end{verbatim}

\caption{Ejemplo de una creencia indirecta.}
\label{fig:creenciaIndirecta}

\end{figure}

En este caso, la creencia \texttt{puedoHacerParry}\ se calcula en base al rol del 
agente,
así como también de la energía del agente. Esto es porque no todos los roles tienen la
acción asociada, por lo que se listan las que sí lo pueden. Por otro lado, el agente
no puede hacer \textit{parry}\ si no tiene por lo menos dos puntos de energía, lo cual
es expresado por la última regla.

\subsubsection{Funciones aritméticas y lógicas}

En la última línea de la Fig. \ref{fig:creenciaIndirecta}, se utiliza la función 
\texttt{less/2}, que es una función de comparación. (En ese caso, devuelve lo mismo
que $Energy < 2$.) Ése es un ejemplo de las diferentes funciones aritméticas y 
lógicas que se encuentran en el subprograma \textit{DeLP}.

Estas reglas se encuentran fuera del lenguaje \textit{DeLP}, y fueron implementadas 
aprovechando su capacidad de consultar a Prolog, utilizando \textit{built in's}.
En la figura \ref{fig:funciones}\ se ejemplifica la manera en que se han 
implementado.

\begin{figure}
\begin{verbatim}    
is_a_built_in(less(_X,_Y)).
is_a_built_in(add(_X,_Y,_Z)).

add(X,Y,Z :- Z is X + Y.
less(X,Y) :- X < Y.
\end{verbatim}

\caption{Ejemplo de una función aritmética y una lógica.}
\label{fig:funciones}
\end{figure}

\subsubsection{Cálculo de pesos}

Utilizando la misma idea que la funciones ariméticas de la sección anterior, el
cálculo de los pesos de los argumentos de deseos se logró utilizando \textit{built 
in's}. Existe uno por cada regla de deseo, salvo que esté fijo, en cuyo caso 
este valor simplemente se encontrará en vez de la varialbe \texttt{Peso}. Un 
ejemplo extraído del código se encuentra en la Fig. \ref{fig:calculoDePeso}.

\begin{figure}
\begin{verbatim}
is_a_built_in(aumentoPeso(_, _, _, _, _)).

aumentoPeso(Turnos, DifPuntos, EnergiaRestante, CoefFase, Peso) :-
    Value is (DifPuntos * 10 + (10 - Dist) ** 2 + EnergyLeft) * CoefFase.
\end{verbatim}

\caption{Ejemplo del cálculo del peso de un argumento de deseo.}
\label{fig:calculoDePeso}
\end{figure}

En este ejemplo, se calcula el peso del deseo \emph{aumento}. Para esto, se utilizan
varios parámetros, entre las cuales se encuentran la cantidad de turnos que 
conllevará realizarlo, y la diferencia de puntos que genera.

Todas estas funciones cumplen con el protocolo de mantener el nombre del deseo,
seguido de ``Peso'' como nombre. A su vez, mantiene todos los parámetros 
necesarios como argumentos, seguido de la variable \texttt{Peso}, en la cual se 
retornará dicho valor.

\subsubsection{Coeficientes y otros valores auxiliares}

En la fórmula de la figura \ref{fig:calculoDePeso}\ se utiliza el valor 
\texttt{CoefFase}. Este valor no pertenece a lo obtenido en las percepciones, ni
directa ni indirectamente, sino que se trata de un valor preestablecido (o
\textit{harcodeado}). Pertenece a esta categoría aparte de creencias predefinidas,
cuyos valores modifican los pesos ya sea de manera aditiva/substractiva, o 
porcentualmente (como es el caso de \texttt{CoefFase}).

En particular, este valor se refiere a un coeficiente que se le aplica a varios
pesos de deseos, que representa la utilidad de cada deseo en la fase actual. El 
concepto de \textit{``fase''}\ se trata de un modificador más del comportamiento
del agente, que cambia de acuerdo a diferentes parámetros, como por ejemplo una
determinada cantidad de turnos, proporción de muertes, porcentaje de mapa explorado,
etc. Fue implementada la interfaz para utilizarla, pero no se expandió a más de una
fase inicial de exploración, por cuestiones de falta de tiempo.

Otros valores caen dentro de esta categoría, como \texttt{agentRolePoints/3}.
Se utiliza para agregar (o sustraer) una determinada cantidad de turnos, dado el
deseo y el rol del agente al cual está apuntado el deseo. Esto sirve para modificar el 
comportamiento de una manera sencilla y modular, para los deseos y roles que los 
necesiten.

Se necesitarían $|D| \times |R|$ reglas para determinar estos valores, siendo $D$
y $R$ los conjuntos de deseos y roles respectivamente. Ésto se simplificó utilizando
un valor por defecto neutral ($0$). Este comportamiento es mostrado
en la Fig. \ref{fig:agentRolePoints}. En éste se muestra la implementación del caso
general, y el caso especial del deseo \emph{reparar}\ para el rol \emph{repairer}.
Agregarle 70 puntos al peso implica darle mayor importancia reparar a otro reparador,
antes que hacerlo con cualquier otro agente.

\begin{figure}
\begin{verbatim}
% en arg.delp
agentRolePoints(_, _, 0) -< true.
	
~agentRolePoints(D, R, 0) <- 
	agentRolePoints(D, R, V),
	notEqual(V, 0).
    
% en repairer.delp
agentRolePoints(reparar, repairer, 70) <- true.
\end{verbatim}
\caption{Implementación de \texttt{agentRolePoints/3}, para el caso general, y para el 
deseo de \emph{reparar}\ para el \emph{repairer}}
\label{fig:agentRolePoints}
\end{figure}


\section{Interfaz con Prolog}

\label{sec:interfazConProlog}

Teniendo ya todos las reglas de deseos, con sus cálculos de pesos, así como el resto 
de las explicadas en la sección \ref{sec:esquemasArgumento}, el agente debe, por un 
lado, asertar (en el sentido de Prolog) todas las creencias, y luego consultar por 
la intención que se llevará a cabo. Todo esto se hace desde el programa Prolog, en
la parte de Argumentación.

Como fue explicado en el capítulo anterior, %REFFFFFFFFF
las creencias se setean de una manera diferenciada, tratando de realizar la menor
cantidad de cálculos posibles, de manera tal de reducir el tiempo de ejecución. Las
utilizadas por el subprograma \textit{DeLP} serán justamente los hechos \textit{DeLP}, 
y la interfaz utilizará los deseos instanciados con sus respectivos parámetros.

El esquema explicado en la sección \ref {sec:ideaGeneral}\ contiene un esquema de 
derrotas diferente al implementado. Nuestro enfoque fue más simple, y consistió en 
hacer una llamada por cada deseo, manteniendo el deseo de mayor peso, y comparándolo 
con el último consultado. De esta manera, simplemente se hace un chequeo por cada 
consulta, lo cual reduce la cantidad de comparaciones a ser computadas, ya que la idea 
original implementada en \textit{DeLP} hubiera realizado una cantidad logarítmica de 
comparaciones con respecto a la cantidad de deseos, al generar el árbol de derrotas. De 
esta manera, se logró el mismo esquema implícitamente.

En la figura \ref{fig:interfazProlog}\ se puede observar el código Prolog que 
ejecuta las diferentes consultas. Se hace uso de varios \texttt{foreach/3}\ para 
recolectar todos los hechos que guardan los deseos instanciados, nombrados como:

\begin{verbatim}
posible[NombreDeseo]
\end{verbatim}

\begin{figure}
\begin{verbatim}
meta(X) :- 
    retractall(mejorMeta(_, _)),
    assert(mejorMeta(_, -1000)), !, % meta con "menos infinito"
    
    foreach(
        b(posibleExplorar( N1)), 
        doNotFail(calcMeta(explorar( N1)))
    ), !,
    foreach(
        b(posibleAumento(N2)), 
        doNotFail(calcMeta(aumento(N2)))
    ), !, 
    foreach(
        b(posibleAuxilio(N3)), 
        doNotFail(calcMeta(auxilio(  N3)))
    ), !,
    
	doNotFail(calcMeta(reagruparse)),
    doNotFail(calcMeta(quedarse(Position))), !,
    rolMetas, % predicado definido en cada rol
    
    mejorMeta(X, _).
    
\end{verbatim}
\caption{Implementación del predicado \texttt{meta/1}, el cual consulta por cada 
deseo.}
\label{fig:interfazProlog}
\end{figure}

Finalmente, se devuelve el deseo con más peso, para ser considerada como intención,
sin su peso, pero con todo el resto de sus parámetros. %el gotti me va a pegar


\section{Selección de la Intención}

El esquema modelo de un argumento de deseo es el que se encuentra en la Fig. 
\ref{fig:modeloArgumento}. Algunos contienen variaciones con respecto a éste, pero
la mayoría comparte esta estructura.

\begin{figure}
\begin{verbatim}
% "Vertice" es el vertice al cual se quiere expandir
aumento(Peso, Vertice) -< 
    % 1 - Primero se colocan las creencias binarias (sí o no).
    esSeguro(Vertice), 
    % 2 - Luego, las creencias difusas.
    % Éstas tienen pueden estar asertadas o no. Si no lo están, significa
    % que no se encontró su valor. Por ejemplo, en el caso de la distancia,
    % si no se encuentra es porque no se encontró camino.
    b(distancia(Vertice, [], Dist, EnergyLeft)),
    b(difPuntosZona(Vertice, DifPuntos)),
    % 3 - Pueden existir razones fuertes para descartar el deseo.
    % En este caso, se trata de que no se considerará expandirse a un 
    % vértice que disminuya la cantidad de puntos.
    greater(DifPuntos, 0),
    % X - Puede haber modificadores, como coeficientes.
    phaseCoef(aumento, Coef),
    % 4 - Finalmente, se calcula el peso, con todos los valores.
    aumentoValue(Dist, DifPuntos, EnergyLeft, Coef, Peso).
\end{verbatim}
\caption{Modelo de deseo. Los números en los comentarios representan los posibles 
puntos de ataque.}
\label{fig:modeloArgumento}
\end{figure}

En el proceso de selección de intención, se atacan, como fue explicado anteriormente,
explícita o implícitamente los deseos, ya sea por razones propias 
para rechazarlo, o por peso. Los puntos de ataque se encuentran expuestos en la Fig. 
\ref{fig:modeloArgumento}.

\subsection{Derrotas propias}

Un deseo puede ser desechado por razones propias. En esta sección se expondrán estos
posibles puntos de ataques.

En la jerga de DeLP, una derrota propia es aquella en la cual uno de los dos 
argumentos que entra en conflicto sale victorioso (se mantiene \emph{undefeated}),
mientras que el otro es derrotado. En nuestro contexto, consideramos a las 
``derrotas propias de argumentos de deseos'' como ``derrotas por razones propias''. 
O sea, se trata de razones por las cuales un argumento de deseo no es seleccionado
para ser la siguiente intención a llevar a cabo.

\subsubsection{Falta de hechos}

\label{sec:faltaDeHechos}

Para los dos primeros puntos del modelo se necesitan hechos previamente asertados 
por el programa Prolog. La falta de estos corresponde con que no pudieron ser 
encontrados, por alguna razón, y por lo tanto impedirán que cualquier deseo 
relacionado no pueda considerarse como válido.

La consulta en DeLP de un literal en cuyas reglas no se puede satisfacer por lo
menos una de las precondiciones, devuelve 
\texttt{undecided}, ya que no pertenece al conjunto de literales sobre los cuales
el programa DeLP puede determinar su veracidad o falsedad. Nuestra idea fue 
considerar estos resultados de la misma manera que con los que devuelvo \texttt{no}
como respuesta, por lo que, dentro de nuestro sistema, estos ``argumentos'' son
considerados como derrotados por razones propias.

\subsubsection{Precondiciones negadas}

Las precondiciones pueden ser encontradas, pero negadas. Esto significa que existen
razones para creer exactamente lo contrario de lo que el argumento de deseo 
necesita para ser considerada válida. Generalmente, este tipo de derrotas se 
encuentran en el punto 1 de la Fig. \ref{fig:modeloArgumento}, pero pueden 
encontrarse también en el punto 3. En estos casos, la consulta sí devuelve 
\texttt{no} como respuesta.

En el caso de \texttt{esSeguro/1}, se define que cualquier vértice es por defecto
seguro, salvo que se especifique lo contrario (esto es, se aserte un hecho
\texttt{~esSeguro}). En Prolog se especificará que un vértice no es seguro cuando
un saboteador enemigo habiilitado se encuentre parado sobre éste.

\subsubsection{Valores inválidos}

El punto de ataque 3 se conforma de reglas que establecen parámetros estrictos
sobre los valores que se obtienen en el punto 2. Se trata de aserciones, no en el 
sentido \textit{prologiano}, sino como una condición que deben cumplir los valores. 

En el caso del ejemplo de la Fig.
\ref{fig:modeloArgumento}, se desechan los vértices hacia los cuales moverse 
implica no ganar puntos, o sea, el valor obtenido en \texttt{difPuntos}\ es no
positiva. Esto es porque no tiene sentido el concepto de \emph{aumentar} una zona
si se pierden puntos.

Se trató de evitar usar este sistema, no porque éste sea ineficiente, sino 
porque este tipo de chequeos pueden realizarse en Prolog, y, siendo el caso que
no lo pasaran, simplemente no aserta la creencia en cuestión. Además, se puede
ahorrar el cálculo de las siguientes creencias relacionadas con el deseo. De esta
manera, la derrota caería en el caso explicado en la sección 
\ref{sec:faltaDeHechos}.

\subsection{Derrotas por Peso}

Siendo el caso que no se genere ninguno de los tipos anteriores de derrotas, el
deseo es un deseo válido, o sea, para tener en cuenta. Entonces, su consulta 
devolverá \texttt{yes}, con su peso asociado, y entrará en conflicto con el resto
de los deseos válidos.

Como fue explicado en la sección \ref{sec:interfazConProlog}, la interfaz con 
Prolog mantiene el deseo con mayor peso hasta que consigue otro que lo destrone.
De esta manera, implícitamente se genera una derrota fuera de DeLP entre 
argumentos de deseo, en la cual sólo gana uno. (En el caso que se encuentre un 
deseo con el mismo peso que el actual, éste se mantiene.) Se puede considerar
que el punto de este tipo de ataque es el punto 4 de la Fig. 
\ref{fig:modeloArgumento}, ya que es donde se calcula el peso del argumento.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Deseos Posibles}

Hasta aquí, se han presentado el marco teórico sobre el cual se trabajó, el contexto
de la competencia, y la manera en que hemos abordado el problema de la selección de
intenciones. A pesar de haber utilizado algunos ejemplos propios del código de los 
agentes, no se han explicado en detalle los diferentes deseos utilizados, y los 
detalles de implementación de éstos, como las decisiones de diseño tomadas.

En este capítulo se abordarán estos temas, de manera tal de mostrar el extenso 
trabajo realizado para la competencia.

\section{Deseos Comunes}

A pesar de tener un comportamiento distinto determinado por los roles, los agentes
tienen un grueso cuerpo de código común, tanto en la arquitectura general, como 
en la parte argumentativa. De esta manera, la mayoría de los deseos implementados son
compartidos por todos los agentes, y representan los comportamientos comunes de éstos.

\subsection{Explorar}

El deseo de explorar se refiere a conocer más el mapa. Es disparado para 
conocer mejor las conexiones entre los vértices (arcos). Se instancia con los vértices
que se encuentran en la frontera del mapa conocido. O sea, en los nodos que se sabe
que existen, pero no necesariamente se conocen todos sus arcos. El plan que genera 
consiste en una serie de \textit{goto's}\ hasta llegar al vértice en cuestión, y 
culmina con un \textit{survey}.

Estos nodos no explorados se calculan en el programa Prolog, teniendo en cuenta los 
nodos agregados al mapa conocido por la última percepción. Se tendrán en cuenta sólo
aquellos que se encuentren a una distancia $r - 1$ del nodo del agente, siendo $r$
el rango de visión de éste. Un vértice explorado se mantendrá así por todo el 
transcurso del partido.

Utiliza los datos de cantidad de turnos que costará el plan, y la diferencia de puntos.
El deseo está dividido en dos con respecto a esta última creencia. En el caso que la
cantidad de turnos sea mucha,



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Consideraciones generales}
% qué iba aca?


\end{document}
